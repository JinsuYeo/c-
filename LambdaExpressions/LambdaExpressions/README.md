#  람다 표현식.  
- C++11에 처음 도입된 후 C++14 및 C++17에서 확장됨.   
- C++ 컴파일러는 behind the scene에서는 람다 표현식에서 익명 함수 객체를 생성해 사용함.   
- Stateless lambda: 매개변수 리스트를 통해 전달된 정보에 대해서만 알고 있음(일반 함수처럼).   
- Stateful lambda: 실행된 환경(environment)의 element를 capture할 수 있기 때문에 더 복잡함.   
-> closure의 개념 등장. 람다 캡쳐 목록을 통해 발생.   
   
## 람다식 등장 이유.  
- C++11 이전에는 함수 객체(주로 STL과 함께)와 함수 포인터(주로 callback으로)가 자주 사용됨.   
-> 문제는 종종 알고리즘을 제어하기 위한 짧은 함수들을 많이 작성해야 한다는 것.      
-> 이러한 함수들을 작은 클래스로 캡슐화하여 함수 객체로 만들어 사용함.   
-> 클래스나 함수가 사용 시점에서 멀리 떨어져서 정의됨. 코드 수정, 유지 보수및 테스트에 문제 발생 가능.   
    ex) STL 알고리즘과 함께 함수 객체 사용한 경우 코드 이해하기 위해서는 함수 객체가 정의된 클래스를 찾고, 함수 객체를 찾아 읽어야 함. 
    또한 컴파일러는 인라인으로 정의되지 않은 함수의 경우 최적화에 능숙하지 않음.   
-> 람다식 사용하면 이러한 문제 해결 가능해짐.   
    But 람다식은 코드 양이 적을 때 사용하는 것이 좋음. 복잡한 코드라면 함수 객체 사용을 고려해야 함.   
- 람다식의 또다른 이점은 컴파일러가 람다에서 클로저 생성한다는 것.   
-> 람다가 존재하는 환경에 접근할 수 있음릉 의미함.


